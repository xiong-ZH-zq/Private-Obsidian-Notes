---
type: math_note
date_creation: 2024-02-26
related_course:
  - "[[NKU 离散结构及其算法]]"
---
# 离散结构的排序算法
## 堆栈排序
下面介绍 Stack sorting algorithm （堆栈排序），算法的流程如下：
现有如下的数组：
$$
\pi_1 \pi_2 \pi_3 \cdots \pi_n
$$
我们构造一个栈，然后进行如下操作：
1. 将 $\pi_1$ 放入栈中；
2. 将 $\pi_2$ 放入栈中：
	- 如果 $\pi_2<\pi_1$ ，此时直接入栈；
	- 如果 $\pi_2 >\pi_1$ ，此时先让 $\pi_1$ 出栈，再 $\pi_2$ 入栈；
3. 之后所有的流程和上述情况类似，必须要让将要入栈的元素小于栈顶的元素才能入栈，否则就一直弹出元素.
4. 最后，没有元素将要入栈时，将所有栈内的元素依次弹出.

### 代码模拟
以下是 Python 代码的模拟程序：

```python
# 堆栈排序
from itertools import permutations

def if_sorted(t:list) -> bool:
	# 检验是否排列成功
	for i in range(len(t)):
		if i+1 != t[i]:
			return False
	return True


def stack_sorting(t:tuple) -> None:
	result = [] 
	stack = []
	for item in t:
		# try except 解决空栈的问题
		try: 
			while item >= stack[-1]:
				result.append(stack.pop())
			stack.append(item)
		except IndexError:
			stack.append(item)
	while stack:
		result.append(stack.pop())
	print(f"{t} 的排序结果为 {result}, 是否排序成功： {if_sorted(result)}")

if __name__ == '__main__':
	# 对 1~n-1 的数列进行排序
	n = 6
	
	# permutations 用于生成所有排列
	arrs = permutations(range(1,n))
	for arr in arrs:
		stack_sorting(arr)
```

### 算法分析与证明
事实上，这个所谓的堆栈排序“算法”并不能给所有的数组都排好序，例如 $231$ ，从左到右：
- $2$ 先入栈；
- $3$ 要入栈的时候，$2$ 需要出栈；
这就已经出现问题，事实上，我们需要的是**小的先出栈**，从而达到排序的效果，但是这个例子中排序失败了。

现在我们关心如下两个问题：

1. 什么样的数组（排列）能一次排序成功？
2. 在刚才的 $231$ 例子中，排序后会变成 $213$ ，此时再进行一次排序就会发现能排序成功为 $123$ . 这是否意味着**所有的排列经过有限次堆栈排序都能排序成功**？如果是，那么这个“有限次”的**上限**是多少？

### 一次排序能成功的条件
在接下来的探讨中，不考虑数组中两个元素相等的情形，并将所有的数组都考虑为 $1,2,\cdots,n$ 的一个排列.

在刚才的例子当中，我们实际上能抽象并推广为如下的排列：
$$
\cdots \pi_{i_1}\cdots \pi_{i_2} \cdots \pi_{i_3}\cdots
$$
其中 $i_1<i_2<i_3$ ，我们的发现实际上能归结为如下的结论：

> 当 $\pi_{i_3}<\pi_{i_1}<\pi_{i_2}$ 时，排序必定不成功.

这个结论是比较显然的，根据大小关系 $\pi_{i_3}$ 必须要比 $\pi_{i_1}$ 要更先弹出到目标数组当中，但是由于 $\pi_{i_2}$ 的存在，$\pi_{i_1}$ 必须弹出，从而导致排序失败.

因此，在有这样的例子之后，这是否是等价条件？我们给出如下的猜想：

>[!faq] 猜想：一次排序成功的等价条件
> 排列：
> $$ \pi_1 \pi_2\cdots \pi_n $$
> 能经过**一次堆栈排序**后排序成功的充要条件是：$\forall i_1,i_2,i_3 (1\leqslant i_1< i_2 < i_3 \leqslant n)$ ，$\pi_{i_3}<\pi_{i_1}<\pi_{i_2}$ 都不成立.

必要性已经阐述，下面考虑充分性：
在 $n=3$ 的时候，有如下的 $5$ 种排列：
$$
123,132,213,312,321
$$
这些排列都能排序成功，详细论证略去；

在 $n> 3$ 时，$\pi_{i_1},\pi_{i_2},\pi_{i_3}$ 有 $5$ 种相对位置情形，和上述的 $5$ 种排列类似，我们只需论证：对于任意的 $3$ 个元素，堆栈排序都能保证它们在最终的排序结果中相对位置关系服从大小关系.

例如，对于 $\pi_{i_2}<\pi_{i_1}<\pi_{i_3}$ 的情形，当操作到 $\pi_{i_2}$ 时，有如下两种可能：

- 此时 $\pi_{i_1}$ 已出栈，这说明 $\exists i (i_1<i<i_2)$ 使得 $\pi_{i_2}<\pi_{i_1}<\pi_i$ ，这就与我们的题设条件矛盾.
- 因此 $\pi_{i_1}$ 此时必须在栈内，并且 $\pi_{i_2}$ 也必须入栈；
- 当 $\pi_{i_3}$ 操作时，此时要么 $\pi_{i_1}$ 和 $\pi_{i_2}$ 都已经出栈（相当于三者排序成功），要么全部或一个在栈内，此时 $\pi_{i_3}$ 要入栈时，二者都必须出栈，从而排序成功.

对于其它的四种情形，排序情况都类似，因此猜想证明完毕. $\square$

### 模式(Pattern)
为了解决第二个问题，接下来考虑将这个问题更符号化，对于排列 $\pi$ ，经过堆栈排序后得到一个新的排列
$$
s(\pi) = \sigma_1 \sigma_2\cdots \sigma_n
$$
我们对不能一次成功排序的结构已经有了描述，但是我们需要一个更好的**组合刻划**，下面引入**模式**的概念.

>[!note] 定义：模式 (Pattern)
>给定 $\pi\in S_n$ ，以及 $\sigma\in S_m$ . 若存在**子字**(subword) ：
> $$ \pi_{i_1}\pi_{i_2}\cdots \pi_{i_m} (i_1<i_2<\cdots<i_m)$$
> 使其大小顺序与 $\sigma$ 相同，就称 $\pi$ 包含 $\sigma$-pattern （$\sigma$ 模式）.

那么此时，我们将之前的命题就能进行改写：一个排列能进行一次堆栈排序就实现排序成功**等价于**该排列具有 $231$-pattern .

如何解决第二个问题？接下来







### 可排序结构的计数
下面考虑
$$
\left\lbrace \pi\in S_n | s(\pi)  = \mathrm{id} \right\rbrace
$$
的集合的元素个数，先给出答案：
$$
\frac{1}{n+1} \binom{2n}{n} = c_n
$$
它被称为**Catalan数**.


## 耐心排序 (Patience Sorting)
